{"pageProps":{"post":{"title":"Factoring Large Semiprimes.","description":"A novel approach to factoring large semiprimes.","image":null,"imagealt":"","htmlContent":"<h1>A New Approach to Factoring Large Semi-Primes: Is It Possible?</h1>\n<p>Years ago, an acquaintance challenged me with a problem, over beers, that I didn’t know to be impossible. I developed a legitimate method for factoring large semi-primes more efficiently—a method that depends on the difference between primes, not on the size of the semi-prime.</p>\n<h2>Understanding Semi-Primes</h2>\n<p>At its most basic, multiplying two prime numbers is straightforward. For instance:</p>\n<p>[ 7 \\times 5 = 35 ]</p>\n<p>However, reversing this process—finding the prime factors from their product, such as determining the two numbers that multiply to 35—can be much harder. The product of two primes, called a semi-prime, is notoriously difficult to factor when the primes are large. This difficulty is a fundamental reason why RSA encryption is so secure: the problem of factoring large semi-primes is computationally intense.</p>\n<h2>Optimizing the Search Space</h2>\n<p>The first step to improving efficiency is reducing the search space. Key observations include:</p>\n<ul>\n<li>( p ) and ( q ) are odd primes.</li>\n<li>( p ) will always be greater than ( \\sqrt{pq} ), while ( q ) will be smaller.</li>\n</ul>\n<p>Even with these constraints, the search space remains large. However, I discovered a method to make it more manageable by refactoring the problem.</p>\n<h2>A Mathematical Approach</h2>\n<p>To refactor ( x = \\sqrt{pq + n^2} ) into expressions for ( p ) and ( q ):</p>\n<p><strong>Start with:</strong>\n[\nx = \\sqrt{pq + n^2}\n]</p>\n<p><strong>Square both sides</strong> to remove the square root:\n[\nx^2 = pq + n^2\n]</p>\n<p><strong>Rearrange to express</strong> ( pq ):\n[\npq = x^2 - n^2\n]</p>\n<p><strong>Assume:</strong>\n[\np = x - n\n]\n[\nq = x + n\n]</p>\n<p><strong>Verify by substituting</strong> ( p ) and ( q ):\n[\npq = (x - n)(x + n) = x^2 - n^2\n]</p>\n<p>Therefore, the refactored expressions are:\n[\np = x - n\n]\n[\nq = x + n\n]</p>\n<p>By incrementing ( x ), we can check if ( p \\times q = pq ). If they do, we’ve found our primes.</p>\n<p>Let’s see this in action:</p>\n<p><strong>For ( pq = 35 ):</strong>\n[\nx = \\sqrt{35 + 1^2} = 6\n]\n[\np = 6 - 1 = 5\n]\n[\nq = 6 + 1 = 7\n]</p>\n<p>Therefore, ( 5 \\times 7 = 35 ), and the factors are correct.</p>\n<p><strong>For ( pq = 77 ):</strong>\n[\nx = \\sqrt{77 + 1^2}\n]</p>\n<p>is not an integer. Try a larger ( n ).</p>\n<p>[\nx = \\sqrt{77 + 2^2} = 9\n]\n[\np = 9 - 2 = 7\n]\n[\nq = 9 + 2 = 11\n]</p>\n<p>Here, ( 7 \\times 11 = 77 ), confirming the factors.</p>\n<h2>Enhancing Efficiency</h2>\n<p>The method effectively narrows down the search to the range of possible differences between the primes, which is significantly smaller than brute-forcing all numbers. This approach can factor a 50-digit semi-prime in milliseconds on modest hardware.</p>\n<p>The algorithm is non-deterministic, meaning that the specific values of ( x ) and ( n ) that lead to a correct factorization can vary, and it relies on iterative searching. Additionally, the method is inherently parallelizable: each range of potential values for ( x ) can be tested simultaneously by different processes or machines, speeding up the overall search.</p>\n<p>By reversing the process—fixing ( x = \\lceil \\sqrt{pq} \\rceil ) and solving for ( n )—we can improve speed further:</p>\n<p>[\nx = \\lceil \\sqrt{pq} \\rceil\n]\n[\nn = \\sqrt{x^2 - pq}\n]</p>\n<p>For instance, for ( pq = 35 ):\n[\nx = 6\n]\n[\nn = \\sqrt{6^2 - 35} = \\sqrt{36 - 35} = \\pm 1\n]</p>\n<p>Thus, ( p = 5 ) and ( q = 7 ), matching our earlier results.</p>\n<h2>Time Complexity</h2>\n<p>To analyze the time complexity of the proposed approach, consider the following:</p>\n<ol>\n<li>\n<p><strong>Incrementing ( x )</strong>: The approach involves starting with ( x ) initialized to ( \\lceil \\sqrt{pq} \\rceil ) and incrementing ( x ) to find suitable values for ( p ) and ( q ). For each ( x ), the computation of ( n ) using ( n = \\sqrt{x^2 - pq} ) is performed in constant time, assuming basic arithmetic operations are ( O(1) ).</p>\n</li>\n<li>\n<p><strong>Checking Validity</strong>: After calculating ( p ) and ( q ), the validation step involves checking if ( p \\times q = pq ), which is also an ( O(1) ) operation.</p>\n</li>\n</ol>\n<p>In the worst-case scenario, the number of potential ( x ) values that need to be checked is proportional to the square root of ( pq ). If ( pq ) is an ( n )-digit number, then ( x ) will range up to approximately ( O(10^{n/2}) ). Thus, the time complexity of the approach is approximately ( O(\\sqrt{pq}) ).</p>\n<h2>Excluding More Values Based on Minimum Distance</h2>\n<p>If the minimum distance between two prime factors ( p ) and ( q ) of a semi-prime ( pq ) is ( \\Delta ), you can exclude all potential pairs where the difference ( |p - q| ) is less than ( \\Delta ). This effectively narrows down your search space.</p>\n<ul>\n<li>If the minimum distance ( \\Delta ) is substantial, such as ( 2^{412} ), you exclude all values where the difference between factors is less than ( \\Delta ).</li>\n<li>This could reduce the number of pairs to check, especially if the actual distance between the two primes ( p ) and ( q ) is much larger than ( \\Delta ).</li>\n</ul>\n<p>For a 1024-bit RSA key, the recommended minimum difference ( \\Delta ) between the two primes ( p ) and ( q ) is calculated using the formula from Section B.3 of the Digital Signature Standard (DSS):</p>\n<p>[ \\Delta > 2^{k/2 - 100} ]</p>\n<p>where ( k ) is the bit length of the RSA modulus. For ( k = 1024 ):</p>\n<p>[ \\Delta > 2^{1024/2 - 100} ]\n[ \\Delta > 2^{512 - 100} ]\n[ \\Delta > 2^{412} ]</p>\n<p>Therefore, the difference between the two primes for a 1024-bit RSA key should be greater than ( 2^{412} ). This condition helps ensure that the primes are sufficiently distinct to maintain the security of the RSA key.</p>\n<h2>Practical Example</h2>\n<p>For a key of length ( n ) bits, where ( pq ) is an ( n )-bit semi-prime, and the minimum distance ( \\Delta ) is ( \\Delta > 2^{k/2 - 100}  ) for some ( k ), the complexity might be updated to:</p>\n<p>[ O(\\sqrt{pq} - 2^{k/2 - 100} ) ]</p>\n<p>Which is still technically ( O(1) )</p>\n<p>This represents a significant improvement over brute-force methods, which have exponential complexity in terms of the number of digits, though it still scales with the size of the semi-prime.</p>\n<p>[\n\\begin{array}{|c|c|c|}\n\\hline\n\\textbf{Key Size (bits)} &#x26; \\textbf{Max Checks} , O(\\sqrt{pq}) &#x26; \\textbf{Brute Force Checks} , O(pq) \\\n\\hline\n8   &#x26; 16                             &#x26; 256                               \\\n16  &#x26; 256                            &#x26; 65,536                            \\\n32  &#x26; 65,536                         &#x26; 4,294,967,296                     \\\n64  &#x26; 4,294,967,296                  &#x26; 18,446,744,073,709,551,616         \\\n128 &#x26; 1.84 \\times 10^{19}            &#x26; 3.4 \\times 10^{38}                \\\n256 &#x26; 3.4 \\times 10^{38}             &#x26; 1.16 \\times 10^{77}               \\\n512 &#x26; 1.16 \\times 10^{77}            &#x26; 1.34 \\times 10^{154}              \\\n1024&#x26; 1.34 \\times 10^{154}           &#x26; 1.80 \\times 10^{308}              \\\n\\hline\n\\end{array}\n]</p>\n<h2>Impact on Cryptography</h2>\n<p>That acquaintance, whom I know to be involved in the Tor ecosystem, later told me that this approach directly influenced the transition to version 3 (v3) onion addresses.</p>\n<p>Tor's v3 addresses moved from RSA to elliptic-curve cryptography (ECC) for several reasons:</p>\n<ul>\n<li><strong>Increased Security</strong>: RSA keys, especially at 1024 bits, are less secure against modern factoring techniques and computational advances.</li>\n<li><strong>Better Efficiency</strong>: ECC provides stronger security with smaller key sizes, making operations faster and more efficient.</li>\n<li><strong>Resistance to Attacks</strong>: ECC is less susceptible to factorization-based attacks, addressing the potential vulnerability highlighted by advanced factorization methods.</li>\n</ul>\n<h2>Conclusion</h2>\n<p>While my method is not a cure-all for cracking RSA encryption, it represented a significant improvement over brute force, particularly for semi-primes with close factors. Tor’s adoption of elliptic-curve cryptography in v3 addresses shows the importance of adapting cryptographic methods in response to evolving threats. If nothing else, it underscores the need for ongoing vigilance and innovation in cryptographic security.</p>\n<p>I hope this approach sparks further discussion and development in the field.</p>\n"},"allPosts":[{"slug":"10_seconds","title":"The 7-10 Second Resume Review - A Flawed Approach to Hiring"},{"slug":"404_jobnotfound","title":"Hiring rejections - the error messages we can't debug"},{"slug":"about_me","title":"About Me"},{"slug":"all_your_base","title":"From Hacking to SaaS - My early career as a freelancer."},{"slug":"bootstraps","title":"The Startup Success Formula - Luck, Wealth, and Rule-Breaking"},{"slug":"credentialism","title":"The Value of a Degree in Employer Markets"},{"slug":"cyber_tourdefrance","title":"AI - The Performance-Enhancing Drug for Software Developers"},{"slug":"government_control","title":"Should Canada Elect Senators?"},{"slug":"hack_the_planet","title":"Factoring Large Semiprimes."},{"slug":"hal_9000","title":"Could AI Govern?"},{"slug":"inevitability","title":"ChatGPT as an Adversarial Tool for Job Applications"},{"slug":"letstalk","title":"Let's talk about hollow words of wisdom"},{"slug":"pieces_of_flair","title":"Anything That is Measured, is Measured."},{"slug":"sportsball","title":"A Trip into Software Hell."},{"slug":"sprint_of_marx","title":"The history of all hitherto existing projects is the history of estimation struggles."},{"slug":"trial_by_fire","title":"Tell me about the last time you broke production."}]},"__N_SSG":true}